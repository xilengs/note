## free和delete的区别

free <->malloc

delete<->new

### 区别

1. malloc/free是c/c++标准库的函数，new/delete除了分配空间还会调用[构造函数](https://so.csdn.net/so/search?q=构造函数&spm=1001.2101.3001.7020)和析构函数进行初始化和清理（清理成员）。 
2. malloc/free需要手动计算类型大小且返回值是void*，new/delete可以自己计算类型大小，返回对应的指针。

delete释放对象数组时：千万不能丢失”[]” 
如果用new 创建对象数组，那么只能使用对象的无参数构造函数。例如 
Obj *objects = new Obj[100]; // 创建100 个动态对象 
不能写成 
Obj *objects = new Obj[100] (1); // 创建100 个动态对象的同时赋初值1 
在用delete 释放对象数组时，留意不要丢了符号‘[]’。例如 
delete []objects; // 正确的用法 
delete objects; // 错误的用法 
后者相当于delete objects[0]，漏掉了另外99 个对象。

在类和对象的时候会有很大区别。在使用malloc和free来处理动态内存的时候，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数；使用new和delete就可以既释放对象的内存的同时，调用这个对象的析构函数。

### 共同之处：

它们都是只把指针所指向的内存释放掉了，并没有把指针本身干掉。在free和delete之后，都需要把指向清理内存的指针置为空，即p=NULL，否则指针指向的内存空间虽然释放了，但是指针p的值还是记录的那块地址，该地址对应的内存是垃圾，p就成了“野指针”。同样会使人认为p是个合法的指针，如果程序较长，我们通常在使用一个指针前会检查p！=NULL，这样就起不到作用了。此时如果再释放p指向的空间，编译器就会报错，因为释放一个已经被释放过的空间是不合法的。而将其置为NULL之后再重复释放就不会产生问题，因为delete一个0指针是安全的。