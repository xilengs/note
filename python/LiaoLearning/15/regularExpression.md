## 正则表达式
正则表达式是一种用来匹字符串的强有力的武器。他的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它"匹配"了，否则，该字符串就是不合法的。

在正则表达式里，如果直接给出字符，就是精准匹配。用**\\d**可以匹配一个数字，**\\w**可以匹配一个字母或者数字，所以：
- '00\d' 可以匹配'007'，但无法匹配'00A'
- '\d\d\d' 可以匹配'010'
- '\w\w\d'可以匹配'py3'

**.** 可以匹配**任意**字符
**\\s** 可以匹配一个空格（也包括Tab等空白符）

要匹配变长的字符，在正则表达式中，用*****表示任意个字符（包括0个），用+号表示至少一个字符，用？表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符：

### 进阶

**[]**表示范围：

- [0-9a-zA-Z\\_]可以表示一个数字、字母或者下划线
- [0-9a-zA-Z\\_]可以表示至少由一个数字、字母或者下划线组成的字符串

A|B可以匹配A或B

^表示行的开头，^\d表示必须以数字开头

$表示行的结束，\d$表示必须以数字结束

### re模块

python提供re模块，包含所有正则表达式的功能。由于python的字符串本身也用\转义，所以要特别注意：
```python
s = 'ABC\\-001'
# 对应的正则表达式字符串变成'ABC\-001'
```

使用python的r前缀，就不用考虑转义的问题了：
```python
s = r'ABC\-001'
```

### 使用正则表达式

match()方法判断是否匹配成功，如果匹配成功，返回一个Match对象，否则返回None。

```python
import re
re.match(r'^\d{3}\-\d{3,8}$, '010-12345')
# <re.Match object; span=(0, 9), match='010-12345'>
re.match(r'^\d{3}\-\d{3,8}$, '010 12345')
# None
```

### 切分字符串

```python
"""
>>> 'a b   c'.split(' ')
['a','b','','','c']
# 无法识别连续的空格 

>>> re.split(r'\s+', 'a b   c')
['a','b','c']
# 加入,
>>> re.split(r'[\s\,]+', 'a,b, c  d')
['a','b','c','d']
>>> re.split(r'[\s\,\;]+', 'a,b;; c  d')
['a','b','c','d']
"""
```

### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串地强大功能。用()表示地就是要提取的分组(Group)。
```cmd
>>> m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
>>> m
<sre.SRE_Match object; span=(0,9), match='010-12345'>
>>> m.group(0)
'010-12345'
>>> m.group(1)
'010'
>>> m.group(2)
'12345'
```



### 贪婪匹配

正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。

